package mintools.viewer;

import java.nio.FloatBuffer;

import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLException;
import javax.media.opengl.glu.GLU;
import javax.swing.JPanel;
import javax.vecmath.Matrix4f;

import mintools.parameters.BooleanParameter;
import mintools.parameters.DoubleParameter;
import mintools.swing.VerticalFlowPanel;

/**
 * Creates a frame buffer object for a shadow map
 * @author kry
 */
public class ShadowMap {

    private DoubleParameter posx = new DoubleParameter( "posx (of light)", 1, -5, 5 );

    private DoubleParameter posy = new DoubleParameter( "posy (of light)", 10, -5, 15 );

    private DoubleParameter posz = new DoubleParameter( "posz (of light)", 2, -5, 5 );

    private float[] lightPosition = new float[4]; 
    
    private int lightNumber = 0;
    
    private DoubleParameter factor = new DoubleParameter( "factor", 3, 0, 16 );
    
    private DoubleParameter offset = new DoubleParameter( "offset", 16000, 1, 16000 );
    
    private BooleanParameter debugDepthMap = new BooleanParameter( "debug depth map" , false );
    
    private BooleanParameter debugLightFrustum = new BooleanParameter( "debug light frustum" , false );

    private DoubleParameter ambient = new DoubleParameter( "ambient", 0.2, 0, 1 );

    private DoubleParameter diffuse = new DoubleParameter( "diffuse", 0.9, 0, 1 );
    
    private DoubleParameter near = new DoubleParameter( "near plane for light", 6.5, 1, 8 );
    
    private DoubleParameter far = new DoubleParameter( "far plane for light" , 12, 8, 24 );
    
    private DoubleParameter fov = new DoubleParameter( "light fov" , 75, 30, 90 );
    
    int depthTextureID;
    int savedFrameBufferID;
    int shadowframeBufferID;    
    int size;
    
    private FloatBuffer depthBufferPixels; // for testing!
    
    /**
     * Creates a shadow map of the given size
     * @param size must be a power of 2
     */
    public ShadowMap( int size ) {
        this.size = size;
    }
    
    /**
     * @return controls for the shadow mapped light
     */
    public JPanel getControls() {
        VerticalFlowPanel vfp = new VerticalFlowPanel();
        vfp.add( posx.getSliderControls(false));
        vfp.add( posy.getSliderControls(false));
        vfp.add( posz.getSliderControls(false));
        vfp.add( offset.getSliderControls(true) );
        vfp.add( factor.getSliderControls(false) );
        vfp.add( debugDepthMap.getControls() );
        vfp.add( debugLightFrustum.getControls() );
        vfp.add( ambient.getSliderControls(false) );
        vfp.add( diffuse.getSliderControls(false) );
        vfp.add( near.getSliderControls(false) );
        vfp.add( far.getSliderControls(false) );
        vfp.add( fov.getSliderControls(false) );
        
        return vfp.getPanel();
    }
    
    /** 
     * Creates a frame buffer object and sets it up as a depth texture for shadow mapping
     * @param drawable
     */
    public void init( GLAutoDrawable drawable ) {
        GL2 gl = drawable.getGL().getGL2();
        
        int[] tmp = new int[1];
        gl.glGetIntegerv(GL.GL_DEPTH_BITS, tmp, 0);
        int depthbits = tmp[0];
        
        // Save the current frame buffer binding        
        gl.glGetIntegerv( GL.GL_FRAMEBUFFER_BINDING, tmp, 0 );
        savedFrameBufferID = tmp[0];

        // Allocate the frame buffer object        
        gl.glGenFramebuffers(1, tmp, 0);
        shadowframeBufferID = tmp[0];
        gl.glBindFramebuffer( GL.GL_FRAMEBUFFER, shadowframeBufferID );

        // Allocate the depth texture
        gl.glGenTextures(1, tmp, 0);
        depthTextureID = tmp[0];
        
        gl.glBindTexture( GL.GL_TEXTURE_2D, depthTextureID ); 
        gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);//LINEAR_MIPMAP_LINEAR );//GL_NEAREST);
        gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);//NEAREST);
        gl.glTexParameteri( GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE );
        gl.glTexParameteri( GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE );
         
        int depthFormat;        
        if ( depthbits == 16 ) {        
            depthFormat = GL.GL_DEPTH_COMPONENT16;
        } else if ( depthbits == 24 ) {
            depthFormat = GL.GL_DEPTH_COMPONENT24;
        } else if ( depthbits == 32 ) {   
            depthFormat = GL.GL_DEPTH_COMPONENT32;
        } else {
            throw new GLException("Unexpected number of depth bits: " + depthbits);
        }
        gl.glTexImage2D(GL.GL_TEXTURE_2D, 0, depthFormat, size, size, 0, GL2.GL_DEPTH_COMPONENT, GL.GL_UNSIGNED_INT, null );

        // Attach the texture to the frame buffer
        gl.glFramebufferTexture2D( GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT, GL.GL_TEXTURE_2D, depthTextureID, 0);        
        gl.glDrawBuffer( GL.GL_NONE );
        gl.glReadBuffer( GL.GL_NONE );

        StringBuilder status = new StringBuilder();
        checkFramebufferStatus(gl, status );
        System.out.println( status );
        
        // Restore the original frame buffer binding
        gl.glBindFramebuffer( GL.GL_FRAMEBUFFER, savedFrameBufferID );
        
        gl.glHint( GL2.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST );
        
        int depthBufferPixelsSize = size * size;
        depthBufferPixels = FloatBuffer.allocate( depthBufferPixelsSize );
        
        copyFlatToMatrix( new float[] {
                0.5f, 0.0f, 0.0f, 0.0f,
                0.0f, 0.5f, 0.0f, 0.0f,
                0.0f, 0.0f, 0.5f, 0.0f,
                0.5f, 0.5f, 0.5f, 1.0f}, biasMatrix );
        
    }        
    
    Matrix4f biasMatrix = new Matrix4f();
    Matrix4f lightProjectionMatrix = new Matrix4f();
    Matrix4f lightViewMatrix = new Matrix4f();
    Matrix4f textureMatrix = new Matrix4f();
    
    float[] cpm = new float[16];
    float[] cvm = new float[16];
    float[] lpm = new float[16];
    float[] lvm = new float[16];
    
    GLU glu = new GLU();
 
    /** 
     * Displays debug information for the shadow mapping, if appropriate check-boxes are selected.
     * @param drawable
     */
    public void displayDebug( GLAutoDrawable drawable ) {
        GL gl = drawable.getGL();
        gl.glEnable(GL.GL_BLEND);
        gl.glBlendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA);
        gl.glLineWidth( 2 );
        // Check to see if the light frustum makes sense        
        if ( debugLightFrustum.getValue() ) {
            debugLightFrustum( drawable );
        }        
        // Check to see if the depth texture makes sense
        if ( debugDepthMap.getValue() ) {
            debug(drawable);
        }
    }
    
    /**
     * Prepares for drawing the light view
     * @param drawable
     */
    public void beginLightPass( GLAutoDrawable drawable ) {
        
        GL2 gl = drawable.getGL().getGL2(); 

        gl.glEnable( GL.GL_POLYGON_OFFSET_FILL );
        gl.glPolygonOffset( factor.getFloatValue(), offset.getFloatValue() );
        
        lightPosition[0] = posx.getFloatValue();
        lightPosition[1] = posy.getFloatValue();
        lightPosition[2] = posz.getFloatValue();
        lightPosition[3] = 1;
        
        float[] colour = { 1, 1, 1, 1 };
        gl.glLightfv(GL2.GL_LIGHT0 + lightNumber, GL2.GL_SPECULAR, colour, 0);
        gl.glLightfv(GL2.GL_LIGHT0 + lightNumber, GL2.GL_DIFFUSE, colour, 0);
        gl.glLightfv(GL2.GL_LIGHT0 + lightNumber, GL2.GL_AMBIENT, colour, 0);
        gl.glLightfv(GL2.GL_LIGHT0 + lightNumber, GL2.GL_POSITION, lightPosition, 0);
        gl.glEnable( GL2.GL_LIGHT0 + lightNumber );
        
        gl.glPushMatrix();
        gl.glGetFloatv( GL2.GL_PROJECTION_MATRIX, cpm, 0 );
        gl.glGetFloatv( GL2.GL_MODELVIEW_MATRIX, cvm, 0 );        
        gl.glLoadIdentity();
        glu.gluPerspective( fov.getValue(), 1.0f, near.getValue(), far.getValue() );
        gl.glGetFloatv( GL2.GL_MODELVIEW_MATRIX, lpm, 0 );
        gl.glLoadIdentity();
        glu.gluLookAt( lightPosition[0], lightPosition[1], lightPosition[2], 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
        gl.glGetFloatv( GL2.GL_MODELVIEW_MATRIX, lvm, 0 );
        gl.glPopMatrix();
        
        // First pass - from light's point of view
        gl.glBindFramebuffer( GL.GL_FRAMEBUFFER, shadowframeBufferID );
        gl.glViewport( 0, 0, size, size );
        gl.glClear( GL.GL_DEPTH_BUFFER_BIT );
        gl.glMatrixMode( GL2.GL_PROJECTION ); 
        gl.glLoadMatrixf( lpm, 0 );
        gl.glMatrixMode( GL2.GL_MODELVIEW );
        gl.glLoadMatrixf( lvm, 0 );
        
        copyFlatToMatrix( lpm, lightProjectionMatrix );
        copyFlatToMatrix( lvm, lightViewMatrix );
        textureMatrix.mul( biasMatrix, lightProjectionMatrix );
        textureMatrix.mul( lightViewMatrix );        
    }
    
    /**
     * Finishes the light view drawing and prepares for normal camera view
     * @param drawable
     */
    public void endLightPass( GLAutoDrawable drawable ) {
        GL2 gl = drawable.getGL().getGL2();
        gl.glDisable( GL.GL_POLYGON_OFFSET_FILL );
        gl.glBindFramebuffer( GL.GL_FRAMEBUFFER, savedFrameBufferID );
        gl.glViewport( 0, 0, drawable.getWidth(), drawable.getHeight() );

        // Next pass - from the object's view
        gl.glMatrixMode( GL2.GL_PROJECTION ); 
        gl.glLoadMatrixf( cpm, 0 );
        gl.glMatrixMode( GL2.GL_MODELVIEW );
        gl.glLoadIdentity();
        gl.glLoadMatrixf( cvm, 0 );
        
        gl.glPolygonOffset( 0, 0 );
    }

    /**
     * sets up rendering for the ambient pass
     * @param drawable
     */
    public void beginAmbientPass( GLAutoDrawable drawable) {
        GL2 gl = drawable.getGL().getGL2();
        gl.glEnable( GL2.GL_LIGHTING );     
        float a = ambient.getFloatValue();
        final float [] black = { 0,0,0,1 };
        float [] acol = { a,a,a, 1 };
        gl.glLightfv(GL2.GL_LIGHT0 , GL2.GL_SPECULAR, black, 0);
        gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, black, 0);
        gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, black, 0);
        gl.glLightModelfv( GL2.GL_LIGHT_MODEL_AMBIENT, acol, 0);
    }
    
    /**
     * signals end of the ambient pass
     * @param drawable
     */
    public void endAmbientPass( GLAutoDrawable drawable ) {
        final float [] black = { 0,0,0,1 };
        GL2 gl = drawable.getGL().getGL2();
        gl.glLightModelfv( GL2.GL_LIGHT_MODEL_AMBIENT, black, 0);
    }
    
    /**
     * Draws the light frustum and light position
     * @param drawable
     */
    public void debugLightFrustum( GLAutoDrawable drawable ) {
        GL2 gl = drawable.getGL().getGL2();
        gl.glDisable( GL2.GL_LIGHTING );
        gl.glColor4f(1,1,1,0.75f);
        gl.glPushMatrix();        
        float[] tmpM = new float[16];
        Matrix4f lpvm = new Matrix4f();
        lpvm.mul( lightProjectionMatrix, lightViewMatrix );
        lpvm.invert();
        copyMatrixToFlat(lpvm, tmpM);        
        gl.glMultMatrixf( tmpM, 0 );
        EasyViewer.glut.glutWireCube(2);
        gl.glPopMatrix();
        gl.glPushMatrix();
        gl.glTranslated( lightPosition[0],lightPosition[1],lightPosition[2] );
        EasyViewer.glut.glutSolidSphere(0.2,16,16);
        gl.glPopMatrix();
        gl.glEnable( GL2.GL_LIGHTING );
    }
    
    /**
     * Prepares for drawing with the shadow map depth test
     * @param drawable
     */
    public void beginShadowMapping(GLAutoDrawable drawable) {
        GL2 gl = drawable.getGL().getGL2();
        
        // ADD up other contributions...
        gl.glEnable( GL.GL_BLEND );
        gl.glBlendFunc( GL.GL_ONE, GL.GL_ONE );//GL.GL_SRC_COLOR, GL.GL_DST_COLOR );
        gl.glDepthFunc( GL.GL_EQUAL );
       
        // Draw with shadow map, layer on the diffuse lighting component only       
        float c1 = diffuse.getFloatValue();
        float [] d = { c1, c1,c1, 1 };
        final float [] black = { 0,0,0,1 };
        gl.glLightfv(GL2.GL_LIGHT0 , GL2.GL_SPECULAR, d, 0); // 
        gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_DIFFUSE, d, 0);
        gl.glLightfv(GL2.GL_LIGHT0, GL2.GL_AMBIENT, black, 0);

        gl.glEnable( GL2.GL_LIGHTING );

        
        gl.glBindTexture( GL.GL_TEXTURE_2D, depthTextureID );
        gl.glEnable( GL.GL_TEXTURE_2D );
        //gl.glGenerateMipmap(GL.GL_TEXTURE_2D);      
        gl.glTexParameteri(GL.GL_TEXTURE_2D, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR_MIPMAP_LINEAR );//GL_NEAREST);

        // Enable shadow comparison
        gl.glTexParameteri( GL.GL_TEXTURE_2D, GL2.GL_TEXTURE_COMPARE_MODE, GL2.GL_COMPARE_R_TO_TEXTURE );
        // Shadow comparison should be true (ie not in shadow) if r<=texture
        gl.glTexParameteri( GL.GL_TEXTURE_2D, GL2.GL_TEXTURE_COMPARE_FUNC, GL.GL_LEQUAL);
        // Shadow comparison should generate an INTENSITY result
        gl.glTexParameteri( GL.GL_TEXTURE_2D, GL2.GL_DEPTH_TEXTURE_MODE, GL2.GL_INTENSITY);        
        // Set alpha test to discard false comparisons
//                gl.glAlphaFunc( GL.GL_GEQUAL, 0.99f );
//                gl.glEnable( GL.GL_ALPHA_TEST );
        
        float[] row0 = new float[4];  textureMatrix.getRow( 0, row0 );        
        float[] row1 = new float[4];  textureMatrix.getRow( 1, row1 );
        float[] row2 = new float[4];  textureMatrix.getRow( 2, row2 );
        float[] row3 = new float[4];  textureMatrix.getRow( 3, row3 );
        
        //Set up texture coordinate generation.
        gl.glTexGeni(GL2.GL_S, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_EYE_LINEAR);
        gl.glTexGeni(GL2.GL_T, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_EYE_LINEAR);
        gl.glTexGeni(GL2.GL_R, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_EYE_LINEAR);
        gl.glTexGeni(GL2.GL_Q, GL2.GL_TEXTURE_GEN_MODE, GL2.GL_EYE_LINEAR);        
        gl.glTexGenfv(GL2.GL_S, GL2.GL_EYE_PLANE, row0, 0 );
        gl.glTexGenfv(GL2.GL_T, GL2.GL_EYE_PLANE, row1, 0 );
        gl.glTexGenfv(GL2.GL_R, GL2.GL_EYE_PLANE, row2, 0 );
        gl.glTexGenfv(GL2.GL_Q, GL2.GL_EYE_PLANE, row3, 0 );
        gl.glEnable(GL2.GL_TEXTURE_GEN_S);
        gl.glEnable(GL2.GL_TEXTURE_GEN_T);
        gl.glEnable(GL2.GL_TEXTURE_GEN_R);
        gl.glEnable(GL2.GL_TEXTURE_GEN_Q);
    }

    /**
     * Finishes drawing with the shadow map depth test
     * @param drawable
     */
    public void endShadowMapping( GLAutoDrawable drawable ) {
        GL gl = drawable.getGL();
        gl.glDisable(GL2.GL_TEXTURE_GEN_S);
        gl.glDisable(GL2.GL_TEXTURE_GEN_T);
        gl.glDisable(GL2.GL_TEXTURE_GEN_R);
        gl.glDisable(GL2.GL_TEXTURE_GEN_Q);
//        gl.glDisable(GL2.GL_ALPHA_TEST);
        
        gl.glDisable( GL.GL_BLEND );
        gl.glDepthFunc( GL.GL_LESS );                    
        gl.glDisable( GL.GL_TEXTURE_2D );
    }

    
    /** 
     * Displays the shadow map in the upper left corner of the window at 1/4 size
     * @param drawable
     */
    public void debug( GLAutoDrawable drawable ) {
        GL2 gl = drawable.getGL().getGL2();
        EasyViewer.beginOverlay(drawable);
        gl.glEnable( GL.GL_TEXTURE_2D );
        gl.glBindTexture( GL.GL_TEXTURE_2D, depthTextureID );
        gl.glRasterPos2f(10, 256 + 10);
        gl.glColor3f(1.f, 1.f, 1.f);
        gl.glGetTexImage( GL.GL_TEXTURE_2D, 0, GL2.GL_DEPTH_COMPONENT, GL.GL_FLOAT, depthBufferPixels );
        //gl.glPixelZoom( 0.25f, 0.25f );
        gl.glPixelZoom(256.f / size, 256.f / size);
        gl.glDrawPixels( size, size, GL.GL_LUMINANCE, GL.GL_FLOAT, depthBufferPixels );
        gl.glPixelZoom( 1, 1 );
        gl.glEnable( GL.GL_DEPTH_TEST );
        EasyViewer.endOverlay(drawable);
    }
    
    private int checkFramebufferStatus(GL gl, StringBuilder statusString) {
        int framebufferStatus = gl.glCheckFramebufferStatus(GL.GL_FRAMEBUFFER);
        switch (framebufferStatus) {
            case GL.GL_FRAMEBUFFER_COMPLETE:
                statusString.append("GL_FRAMEBUFFER_COMPLETE");
                break;
            case GL.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENTS");
                break;
            case GL.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case GL.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case GL.GL_FRAMEBUFFER_INCOMPLETE_FORMATS:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_FORMATS");
                break;
            case GL2.GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER");
                break;
            case GL2.GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:
                statusString.append("GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER");
                break;
            case GL.GL_FRAMEBUFFER_UNSUPPORTED:
                statusString.append("GL_FRAMEBUFFER_UNSUPPORTED");
                break;
        }
        return framebufferStatus;
    }
    
    /**
     * Copies the Matrix4f to the float array
     * @param src 
     * @param dst
     */
    public static void copyMatrixToFlat( Matrix4f src, float[] dst ) {
        dst[0] = src.m00;
        dst[1] = src.m10;
        dst[2] = src.m20;
        dst[3] = src.m30;
        dst[4] = src.m01;
        dst[5] = src.m11;
        dst[6] = src.m21;
        dst[7] = src.m31;
        dst[8] = src.m02;
        dst[9] = src.m12;
        dst[10] = src.m22;
        dst[11] = src.m32;
        dst[12] = src.m03;
        dst[13] = src.m13;
        dst[14] = src.m23;
        dst[15] = src.m33;
    }
    
    /**
     * Copies the float array to the Matrix4f
     * @param src 
     * @param dst
     */
    public static void copyFlatToMatrix( float[] src, Matrix4f dst ) {
        dst.m00 = src[0];
        dst.m10 = src[1];
        dst.m20 = src[2];
        dst.m30 = src[3];
        dst.m01 = src[4];
        dst.m11 = src[5];
        dst.m21 = src[6];
        dst.m31 = src[7];
        dst.m02 = src[8];
        dst.m12 = src[9];
        dst.m22 = src[10];
        dst.m32 = src[11];
        dst.m03 = src[12];
        dst.m13 = src[13];
        dst.m23 = src[14];
        dst.m33 = src[15];
    }
}
